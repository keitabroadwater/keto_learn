"""
Basic Matrix Calculations and Operations:

The basis for these calculation is the python list. So, this is only for insight and education, not performance.
"""

from typing import List, Tuple, Callable, Union
import copy

Matrix = List[List[float]]
Vector = List[float]



def shape(A: Matrix) -> Tuple[int, int]:
    """Returns (# of rows of A, # of columns of A)"""

    num_rows = len(A)
    num_cols = len(A[0])

    return num_rows, num_cols


def get_row(A: Matrix, i: int) -> List[float]:
    """Returns the ith row of Matrix A"""

    return A[i]


def get_column(A: Matrix, i: int) -> List[float]:
    """Returns the ith column of Matrix A"""

    return [x[i] for x in A]


def make_matrix(num_rows: int, num_cols: int, entry_fn: Callable[[int, int], float]) -> Matrix:

    """returns an Matrix with num_rows and num_cols.
        whose (i,j)th entry is generated by the entry function (i,j)"""

    return [[entry_fn(i, j)             # given i, create a list
            for j in range(num_cols)]   # [entry)fun(i, 0), ... ]
            for i in range(num_rows)]   # create one list for each i


def identity_matrix(num: int) -> Matrix:
    """Generates a matrix with num rows and num columns"""

    return make_matrix(num, num, lambda i, j: 1 if i == j else 0)


def zeros(num_row: int, num_col: int) -> Matrix:
    """Returns a matrix of numrows and numcols of zeros"""

    return make_matrix(num_row, num_col, lambda i,j: 0)


def ones(num_row: int, num_col: int) -> Matrix:
    """Returns a matrix of numrows and numcols of ones"""

    return make_matrix(num_row, num_col, lambda i,j: 1)

def matrix_add(A: Matrix, B: Matrix) -> Matrix:
    """Does elementwise addition of two same sized matrices"""

    # Check that matrices are same shape
    matrix_shape = shape(A)
    assert matrix_shape == shape(B), "matrices are not same shape!"

    # Add the matrices element wise
    output_matrix = zeros(matrix_shape[0], matrix_shape[1])

    for i in range(matrix_shape[0]):
        for j in range(matrix_shape[1]):

            output_matrix[i][j] = A[i][j] + B[i][j]

    return output_matrix


def matrix_subtract(A: Matrix, B: Matrix) -> Matrix:
    """Does elementwise subtraction of two same sized matrices"""

    # Check that matrices are same shape
    matrix_shape = shape(A)
    assert matrix_shape == shape(B), "matrices are not same shape!"

    # Add the matrices element wise
    output_matrix = zeros(matrix_shape[0], matrix_shape[1])

    for i in range(matrix_shape[0]):
        for j in range(matrix_shape[1]):
            output_matrix[i][j] = A[i][j] - B[i][j]

    return output_matrix


def matrix_mult_hadamard(A: Matrix, B: Matrix) -> Matrix:
    """Does elementwise multiplication of two same sized matrices.
        Otherwise know as a Hadamard product"""

    # Check that matrices are same shape
    matrix_shape = shape(A)
    assert matrix_shape == shape(B), "matrices are not same shape!"

    # Add the matrices element wise
    output_matrix = zeros(matrix_shape[0], matrix_shape[1])

    for i in range(matrix_shape[0]):
        for j in range(matrix_shape[1]):
            output_matrix[i][j] = A[i][j] * B[i][j]

    return output_matrix


def vector_to_matrix(v: Vector) -> Matrix:
    """Inputs a vector, returns a matrix of shape 1,0 """

    return [v]


def matrix_to_vector(A: Matrix) -> Vector:
    """Inputs a matrix of size 1, x; returns a vector"""

    # check size

    assert shape(A)[0] == 1, "matrix must have shape 1,0 !"

    # create vector

    return A[0]


def dot_product(A: Matrix, B: Union[Matrix, Vector, float], dot_type: str) -> Union[Matrix, Vector]:
    """Performs dot products between a Matrix, and a matrix, vector or scalar.

        Parameters: A: input Matrix
                    B: input Matrix, Vector, or scalar
                    C: dot_type. A string that specifies the type of dot product ("matrix", "vector", or "scalar")

        For Matrix/Matrix dot product, the number of columns of A must match the number of
        rows of B. The result is a matrix with the number of rows of A.

        For Matrix/Vector dot products, the number of columns of A must match the number of elements
        in v. The result is a Vector with the same number of items as the rows in A.

        For Matrix/scalar dot products, the result is simply a matrix of the same size as A. To produce this matrix
        elementwise multiplication is done on A with the scalar."""

    input_matrix_a_shape = shape(A)

    # Check input types and shapes
    if dot_type == 'matrix':

        input_matrix_b_shape = shape(B)

        assert input_matrix_a_shape[1] == input_matrix_b_shape[0], "matrix A's columns must match matrix B's rows!"

    elif dot_type == 'vector':

        input_vector_length = len(B)

        assert input_matrix_a_shape[1] == input_vector_length, "matrix A's columns must match the vector's length!"

    # Perform dot products

    if dot_type == 'matrix':
        # create empty matrix
        output_object = zeros(input_matrix_a_shape[0], input_matrix_b_shape[1])

        for i in range(input_matrix_a_shape[0]):

            for j in range(input_matrix_b_shape[1]):

                output_object[i][j] = sum([x_i * y_i for x_i,y_i in zip(A[i], get_column(B,j))])

    elif dot_type == 'vector':
        output_object = [0]*input_matrix_a_shape[0]

        for i in range(input_matrix_a_shape[0]):

            output_object[i] = sum([x_i * y_i for x_i,y_i in zip(A[i], B)])

    elif dot_type == 'scalar':

        output_object = A.copy()

        for i in range(input_matrix_a_shape[0]):
            output_object[i] = [x_i * B for x_i in A[i]]

    return output_object

def transpose(A: Matrix) -> Matrix:
    """Returns the transpose of a matrix.

        This is done by making the columns of the input matrix the rows of the output matrix"""

    shape_a = shape(A)

    shape_output = (shape_a[1], shape_a[0])

    output = zeros(shape_output[0], shape_output[1])

    for i in range(shape_a[1]):
        output[i] = get_column(A, i)

    return output

def square(A: Matrix) -> bool:
    """Tests squareness of a matrix"""

    shape_input = shape(A)

    return shape_input[0] == shape_input[1]


def determinant(B: Matrix) -> float:
    """Calculate the determinant of a square matrix."""


    assert square(B), 'input must be a square matrix'
    if shape(B) == (1, 1):  # determinant of 1x1 matrix is the only value
        return B[0][0]

    # base case

    # check for squareness and 2x2ness
    if shape(B) == (2, 2):

        # do base case determinant calc

        determt = B[0][0] * B[1][1] - B[0][1] * B[1][0]
        return determt


    # Recursive case
    else:

        # create the float multipliers from the first row

        factor_floats = B[0]

        # create the matrix multipliers
        matrix_multipliers_base = B[1:]
        matrix_multipliers = []
        for i, x in enumerate(factor_floats):
            copymm = copy.deepcopy(matrix_multipliers_base)
            [y.pop(i) for y in copymm]
            matrix_multipliers.append(copymm)

        # Create the alternating +1/-1 factors
        neg_factors = []
        for i in range(len(factor_floats)):
            if i % 2 == 0:
                neg_factors.append(1)

            else:
                neg_factors.append(-1)

        return sum([neg_factors[i] * determinant(matrix_multipliers[i]) * factor_floats[i]
                    for i in range(len(factor_floats))])


def adjoint(A: Matrix) -> Matrix:
    """Inspired by https://www.geeksforgeeks.org/adjoint-inverse-matrix/"""

    # Check for squareness
    assert square(A), "matrix must be square!"
    shape_a = shape(A)
    assert shape_a != (1, 1), "matrix must be larger than 1x1"

    # Build Adjoint Matrix

    adj = zeros(shape_a[0], shape_a[1])

    for i in range(shape_a[0]):

        for j in range(shape_a[1]):
            copya = copy.deepcopy(A)

            copya.pop(i)
            [y.pop(j) for y in copya]

            adj[j][i] = (-1) ** (i + j) * determinant(copya)

    return adj


def inverse(A: Matrix) -> Matrix:
    """get the inverse of a matrix"""

    if determinant(A) != 0:
        invrse = adjoint(A)/determinant(A)  # Need to create matrix division operator
        return invrse

    else:
        print("Inverse doesn't exist")

# Matrix Operations

# 1. Transpose DONE
# 2. Adjoint DONE
# 2. Inverse
# 3. Trace
# 4. Determinant DONE
# 5. Rank

# Matrix type checks

# 1. Square Matrix DONE
# 2. Symmetric Matrix
# 3. Triangular Matrix
# 4. Diagonal Matrix
# 5. Identity Matrix
# 6. Orthogonal Matrix