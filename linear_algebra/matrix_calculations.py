"""
Basic Matrix Calculations and Operations:

The basis for these calculation is the python list. So, this is only for insight and education, not performance.
"""

from typing import List, Tuple, Callable, Union

Matrix = List[List[float]]
Vector = List[float]



def shape(A: Matrix) -> Tuple[int, int]:
    """Returns (# of rows of A, # of columns of A)"""

    num_rows = len(A)
    num_cols = len(A[0])

    return num_rows, num_cols


def get_row(A: Matrix, i: int) -> List[float]:
    """Returns the ith row of Matrix A"""

    return A[i]


def get_column(A: Matrix, i: int) -> List[float]:
    """Returns the ith column of Matrix A"""

    return [x[i] for x in A]


def make_matrix(num_rows: int, num_cols: int, entry_fn: Callable[[int, int], float]) -> Matrix:

    """returns an Matrix with num_rows and num_cols.
        whose (i,j)th entry is generated by the entry function (i,j)"""

    return [[entry_fn(i, j)             # given i, create a list
            for j in range(num_cols)]   # [entry)fun(i, 0), ... ]
            for i in range(num_rows)]   # create one list for each i


def identity_matrix(num: int) -> Matrix:
    """Generates a matrix with num rows and num columns"""

    return make_matrix(num, num, lambda i, j: 1 if i == j else 0)


def zeros(num_row: int, num_col: int) -> Matrix:
    """Returns a matrix of numrows and numcols of zeros"""

    return make_matrix(num_row, num_col, lambda i,j: 0)


def ones(num_row: int, num_col: int) -> Matrix:
    """Returns a matrix of numrows and numcols of ones"""

    return make_matrix(num_row, num_col, lambda i,j: 1)

def matrix_add(A: Matrix, B: Matrix) -> Matrix:
    """Does elementwise addition of two same sized matrices"""

    # Check that matrices are same shape
    matrix_shape = shape(A)
    assert matrix_shape == shape(B), "matrices are not same shape!"

    # Add the matrices element wise
    output_matrix = zeros(matrix_shape[0], matrix_shape[1])

    for i in range(matrix_shape[0]):
        for j in range(matrix_shape[1]):

            output_matrix[i][j] = A[i][j] + B[i][j]

    return output_matrix


def matrix_subtract(A: Matrix, B: Matrix) -> Matrix:
    """Does elementwise subtraction of two same sized matrices"""

    # Check that matrices are same shape
    matrix_shape = shape(A)
    assert matrix_shape == shape(B), "matrices are not same shape!"

    # Add the matrices element wise
    output_matrix = zeros(matrix_shape[0], matrix_shape[1])

    for i in range(matrix_shape[0]):
        for j in range(matrix_shape[1]):
            output_matrix[i][j] = A[i][j] - B[i][j]

    return output_matrix


def matrix_mult_hadamard(A: Matrix, B: Matrix) -> Matrix:
    """Does elementwise multiplication of two same sized matrices.
        Otherwise know as a Hadamard product"""

    # Check that matrices are same shape
    matrix_shape = shape(A)
    assert matrix_shape == shape(B), "matrices are not same shape!"

    # Add the matrices element wise
    output_matrix = zeros(matrix_shape[0], matrix_shape[1])

    for i in range(matrix_shape[0]):
        for j in range(matrix_shape[1]):
            output_matrix[i][j] = A[i][j] * B[i][j]

    return output_matrix


def vector_to_matrix(v: Vector) -> Matrix:
    """Inputs a vector, returns a matrix of shape 1,0 """

    return [v]


def matrix_to_vector(A: Matrix) -> Vector:
    """Inputs a matrix of size 1, x; returns a vector"""

    # check size

    assert shape(A)[0] == 1, "matrix must have shape 1,0 !"

    # create vector

    return A[0]


def dot_product(A: Matrix, B: Union[Matrix, Vector, float], dot_type: str) -> Union[Matrix, Vector]:
    """Performs dot products between a Matrix, and a matrix, vector or scalar.

        Parameters: A: input Matrix
                    B: input Matrix, Vector, or scalar
                    C: dot_type. A string that specifies the type of dot product ("matrix", "vector", or "scalar")

        For Matrix/Matrix dot product, the number of columns of A must match the number of
        rows of B. The result is a matrix with the number of rows of A.

        For Matrix/Vector dot products, the number of columns of A must match the number of elements
        in v. The result is a Vector with the same number of items as the rows in A.

        For Matrix/scalar dot products, the result is simply a matrix of the same size as A. To produce this matrix
        elementwise multiplication is done on A with the scalar."""

    input_matrix_a_shape = shape(A)

    # Check input types and shapes
    if dot_type == 'matrix':

        input_matrix_b_shape = shape(B)

        assert input_matrix_a_shape[1] == input_matrix_b_shape[0], "matrix A's columns must match matrix B's rows!"

    elif dot_type == 'vector':

        input_vector_length = len(B)

        assert input_matrix_a_shape[1] == input_vector_length, "matrix A's columns must match the vector's length!"

    # Perform dot products

    if dot_type == 'matrix':
        # create empty matrix
        output_object = zeros(input_matrix_a_shape[0], input_matrix_b_shape[1])

        for i in range(input_matrix_a_shape[0]):

            for j in range(input_matrix_b_shape[1]):

                output_object[i][j] = sum([x_i * y_i for x_i,y_i in zip(A[i], get_column(B,j))])

    elif dot_type == 'vector':
        output_object = [0]*input_matrix_a_shape[0]

        for i in range(input_matrix_a_shape[0]):

            output_object[i] = sum([x_i * y_i for x_i,y_i in zip(A[i], B)])

    elif dot_type == 'scalar':

        output_object = A.copy()

        for i in range(input_matrix_a_shape[0]):
            output_object[i] = [x_i * B for x_i in A[i]]

    return output_object



